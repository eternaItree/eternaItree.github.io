---
layout: single
title: "Escaping the Google kCTF Container with a Data-Only Exploit"
date: 2023-07-29
classes: wide
header:
  teaser: /assets/images/avatar.jpg
tags:
  - Linux kernel
  - Pwn
  - UAF
  - Tutorial
  - CTF
  - Walkthrough
---

## Introduction
I've been doing some Linux kernel exploit development/study and vulnerability research off and on since last Fall and a few months ago I had some downtime on vacation to sit and challenge myself to write my first data-only exploit for a real bug that was exploited in kCTF. `io_ring` has been a popular target in the program's history up to this point, so I thought I'd find an easy-to-reason-about bug there that had already been exploited as fertile ground for exploit development creativity. The bug I chose to work with was one which resulted in a `struct file` UAF where it was possible to hold an open file descriptor to the freed object. There have been quite a few write-ups on `file` UAF exploits, so I decided as a challenge that my exploit had to be data-only. The parameters of the self-imposed challenge were completely arbitrary, but I just wanted to try writing an exploit that didn't rely on hijacking control flow. I have written quite a few Linux kernel exploits of real kCTF bugs at this point, probably 5-6 as practice, just starting with the vulnerability and going from there, but all of them have ended up in me using ROP, so this was my first try at data-only. I also had not seen a data-only exploit for a `struct file` UAF yet, which was encouraging as it seemed it was worthwile "research". Also, before we get too far, please do not message me to tell me that someone already did xyz years prior. I'm very new to this type of thing and was just doing this as a personal challenge, if some aspects of the exploit are unoriginal, that is by coincidence. I will do my best to cite all my inspiration as we go. 

## The Bug
The [bug](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fc7222c3a9f56271fba02aabbfbae999042f1679) is extremely simple (why can't I find one like this?) and was exploited in [kCTF](https://docs.google.com/spreadsheets/d/e/2PACX-1vS1REdTA29OJftst8xN5B5x8iIUcxuK6bXdzF8G1UXCmRtoNsoQ9MbebdRdFnj6qZ0Yd7LwQfvYC2oF/pubhtml#) in November of last year. I didn't look very hard or ask around in the kCTF discord, but I was not able to find a PoC for this particular exploit. I was able to find several good write-ups of exploits leveraging similar vulnerabilities, especially this one by [pqlpql](https://twitter.com/pqlqpql) and [Awarau](https://twitter.com/Awarau1): <https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/>. 

I won't go into the bug very much because it wasn't really important to the excercise of being creative and writing a new kind of exploit (new for me); however, as you can tell from the patch, there was a call to put (decrease) a reference to a file without first checking if the file was a fixed file in the io_uring. There is this concept of fixed files which are managed by the io_uring itself, and there was this pattern throughout that codebase of doing checks on request files before putting them to ensure that they were not fixed files, and in this instance you can see that the check was not performed. So we are able from userspace to open a file (refcount == 1), register the file as a fixed file (recount == 2), call into the buggy code path by submitting an `IORING_OP_MSG_RING` request which, upon completion will erroneously decrement the refcount (refcount == 1), and then finally, call `io_uring_unregister_files` which ends up decrementing the recount to 0 and freeing the file while we still maintain an open file descriptor for it. This is about as good as bugs get. I need to find one of these.

What sort of variant analysis can we perform on this type of bug? I'm not so sure, it seems to be a broad category. But the careful code reviewer might have noticed that everywhere else in the codebase there was the potential of putting a request file, the authors made sure to check if the file was fixed or not. This file put forgot to perform the check. The broad lesson I learned from this was to try and find instances of an action being performed multiple times in a codebase and look for descrepancies between those routines. 

## Giant Shoulders
It's extremely important to stress that the blogpost I linked above from @pqlpql and @Awarau1 was very instrumental to this process. In that blogpost they broke-down in exquisite detail how to coerce the Linux kernel to free an entire page of `file` objects back to the page allocator by utilizing a technique called "cross-cache". `file` structs have their own dedicated cache in the kernel and so typical object replacement shenanigans in UAF situations aren't very useful in this instance, regardless of the `struct file` size. Thanks to their blogpost, the concept of "cross-cache" has been used and discussed more and more, at least on Twitter from my anecdotal experience. 

Instead of using this trick of getting our entire victim page of `file` objects sent back to the page allocator only to have the page used as the backing for general cache objects, I elected to have the page reallocated in the form of the a pipe buffer. Please see this [blogpost](https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel) by [@pqlpql](https://twitter.com/pqlqpql) for more information (this is a great writeup in general). This is an extremely powerful technique because we control all of the contents of the pipe buffer (via writes) and we can read 100% of the page contents (via reads). It's also extremely reliable in my expierence. I'm not going to go into too much depth here because this wasn't any of my doing, this is 100% the people mentioned thus far. Please go read the material from them.

## Arbitrary Read
The first thing I started to look for, was a way to leak data, because I've been hardwired to think that all Linux kernel exploits follow the same pattern of achieving a leak which defeats KASLR, finding some valuable objects in memory, overwriting a function pointer blah blah blah. (Turns out this is not the case and some really talented people have really opened my mind in this area.) The only thing I knew for certain at this point was I have an open file descriptor at my disposal so let's go looking around the file system code in the Linux kernel. One of the first things that caught my eye was the `fcntl` syscall in `fs/fcntl.c`. In general what I was doing at this point, was going through syscall tables for the Linux kernel and seeing which syscalls took an `fd` as an argument. From there, I would visit the portion of the kernel codebase which handled that syscall implementation and I would `ctrl-f` for the function `copy_to_user`. This seemed like a relatively logical way to find a method of leaking data back to userspace. 

The `copy_to_user` function is a key part of the Linux kernel's interface with user space. It's used to copy data from the kernel's own memory space into the memory space of a user process. This function ensures that the copy is done safely, respecting the separation between user and kernel memory.

Now if you go to the [source code](https://elixir.bootlin.com/linux/v5.19/source/fs/fcntl.c) and do the find on `copy_to_user`, the 2nd result is a snippet in this bit right here:
```c
static long fcntl_rw_hint(struct file *file, unsigned int cmd,
			  unsigned long arg)
{
	struct inode *inode = file_inode(file);
	u64 __user *argp = (u64 __user *)arg;
	enum rw_hint hint;
	u64 h;

	switch (cmd) {
	case F_GET_RW_HINT:
		h = inode->i_write_hint;
		if (copy_to_user(argp, &h, sizeof(*argp)))
			return -EFAULT;
		return 0;
	case F_SET_RW_HINT:
		if (copy_from_user(&h, argp, sizeof(h)))
			return -EFAULT;
		hint = (enum rw_hint) h;
		if (!rw_hint_valid(hint))
			return -EINVAL;

		inode_lock(inode);
		inode->i_write_hint = hint;
		inode_unlock(inode);
		return 0;
	default:
		return -EINVAL;
	}
}
```

You can see that in the `F_GET_RW_HINT` case, a `u64` ("h"), is copied back to userspace. That value comes from the value of `inode->i_write_hint`. And `inode` itself is returned from `file_inode(file)`. The source code for that function is as follows:
```c
static inline struct inode *file_inode(const struct file *f)
{
	return f->f_inode;
}
```

Lol, well then. If we control the `file`, then we control the `inode` as well. A `struct file` looks like this:
```c
struct file {
	union {
		struct llist_node	fu_llist;
		struct rcu_head 	fu_rcuhead;
	} f_u;
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
<SNIP>
```

And since we're using the pipe buffer as our replacement object (really the entire page), we can set `inode` to be an arbitrary address. Let's go check out the `inode` struct and see what we can learn about this `i_write_hint` member.
```c
struct inode {
	umode_t			i_mode;
	unsigned short		i_opflags;
	kuid_t			i_uid;
	kgid_t			i_gid;
	unsigned int		i_flags;

#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl;
	struct posix_acl	*i_default_acl;
#endif

	const struct inode_operations	*i_op;
	struct super_block	*i_sb;
	struct address_space	*i_mapping;

#ifdef CONFIG_SECURITY
	void			*i_security;
#endif

	/* Stat data, not accessed from path walking */
	unsigned long		i_ino;
	/*
	 * Filesystems may only read i_nlink directly.  They shall use the
	 * following functions for modification:
	 *
	 *    (set|clear|inc|drop)_nlink
	 *    inode_(inc|dec)_link_count
	 */
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t			i_rdev;
	loff_t			i_size;
	struct timespec64	i_atime;
	struct timespec64	i_mtime;
	struct timespec64	i_ctime;
	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
	unsigned short          i_bytes;
	u8			i_blkbits;
	u8			i_write_hint;
<SNIP>
```
So `i_write_hint` is a `u8`, aka, a single byte. This is perfect for what we need, `inode` becomes the address from which we read a byte back to userland (plus the offset to the member). 

Since we control 100% of the backing data of the `file`, we thus control the value of the `inode` member. So if we set up a fake `file` struct in memory via our pipe buffer and have the `inode` member be `0x1337`, the kernel will try to deref `0x1337` as an address and then read a byte at the offset of the `i_write_hint` member. So this is an arbitrary read for us, and we found it in the dumbest way possible.

This was really encouraging for me that we found an arbitrary read gadget so quickly, but what should we aim the read at?

## Finding a Read Target 
So we can read data at any address we want, but we don't know what to read. I struggled thinking about this for a while, but then remembered that the `cpu_entry_area` was not randomized boot to boot, it is always at the same address. I knew this from the above blogpost about the `file` UAF, but also vaguely from [@ky1ebot](https://twitter.com/ky1ebot) tweets like [this one](https://twitter.com/ky1ebot/status/1601231194062192640?s=20). 

`cpu_entry_area` is a special per-CPU area in the kernel that is used to handle some types of interrupts and exceptions. There is this concept of [Interrupt Stacks](https://docs.kernel.org/next/x86/kernel-stacks.html) in the kernel that can be used in the event that an exception must be handled for instance. 

After doing some debugging with GDB, I noticed that there was at least one kernel text pointer that consistently showed up in the `cpu_entry_area` consistently and that was an address inside the `error_entry` function which is as follows:
```c
SYM_CODE_START_LOCAL(error_entry)
	UNWIND_HINT_FUNC

	PUSH_AND_CLEAR_REGS save_ret=1
	ENCODE_FRAME_POINTER 8

	testb	$3, CS+8(%rsp)
	jz	.Lerror_kernelspace

	/*
	 * We entered from user mode or we're pretending to have entered
	 * from user mode due to an IRET fault.
	 */
	swapgs
	FENCE_SWAPGS_USER_ENTRY
	/* We have user CR3.  Change to kernel CR3. */
	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax
	IBRS_ENTER
	UNTRAIN_RET

	leaq	8(%rsp), %rdi			/* arg0 = pt_regs pointer */
.Lerror_entry_from_usermode_after_swapgs:

	/* Put us onto the real thread stack. */
	call	sync_regs
	RET
<SNIP>
```

`error_entry` seemed to be used as an entry point for handling various exceptions and interrupts, so it made sense to me that an offset inside the function, might be found on what I was guessing was an interrupt stack in the `cpu_entry_area`. The address was the address of the `call sync_regs` portion of the function. I was never able to confirm what types of common exceptions/interrupts would've been taking place on the system that was pushing that address onto the stack presumably when the `call` was executed, but maybe someone can chime in and correct me if I'm wrong about this portion of the exploit. It made sense to me at least and the address' presence in the `cpu_entry_area` was extremely common to the point that it was never absent during my testing. Armed with a kernel text address at a known offset, we could now defeat KASLR with our arbitrary read. At this point we have the read, the read target, and KASLR defeated. 

Again, this portion didn't take very long to figure out because I had just been introduced to `cpu_entry_area` by the aforementioned blogposts at the time.

## Where are the Write Gadgets?
I actually struggled to find a satisfactory write gadget for a few days. I was kind of spoiled by my experience finding my arbitrary read gadget and thought this would be a similarly easy search. I followed roughly the same process of going through syscalls which took an `fd` as an argument and tracing through them looking for calls to `copy_to_user`, but I didn't have the same luck. During this time, I was discussing the topic with my very talented friend [@Firzen14](https://twitter.com/Firzen14) and he brought up this concept here: <https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html#h.yfq0poarwpr9>. In the P0 blogpost, they talk about how the `signalfd_ctx` of a `signalfd` file is stored in the `f.file->private_data` field and how the `signalfd` syscalls allows the attacker to perform a write of the `ctx->sigmask`. So in our situation, since we control the entire fake file contents, forging a fake `signalfd_ctx` in memory would be quite easy since we have access to an entire page of memory. 

I couldn't use this technique for my personally imposed challenge though since the technique was already published. But this did open my eyes to the concept of storing contexts and objects in the `private_data` field of our `struct file`. So at this point, I went hunting for usages of `private_data` in the kernel code base. As you can see, the member is used in many many places: <https://elixir.bootlin.com/linux/latest/C/ident/private_data>.

This was very encouraging to me since I was bound to find some way to achieve an arbitrary write with so many instances of the member being used in so many different code paths; however, I still struggled a while finding a suitable gadget. Finally, I decided to look back at `io_uring` itself. 

Looking for instances where the `file->private_data` was used, I quickly found an instance right in the very function that was related to the bug. In [`io_msg_ring`](https://elixir.bootlin.com/linux/v5.19/source/fs/io_uring.c#L5244), you can see that a `target_ctx` of type `io_ring_ctx` is derived from the `req->file->private` data. Since we control the fake `file`, we control can control the `private_data` contents (a pointer to a fake `io_ring_ctx` in this case). 

`io_msg_ring` is used to pass data from one io ring to another, and you can see that in `io_fill_cqe_aux`, we actually retrieve a `io_uring_cqe` struct from our potentially faked `io_uring_ctx` via `io_get_cqe`. Immediately, we see several `WRITE_ONCE` macros used to write data to this object. This was looking extremely promising. I initially was going to use this write as my gadget, but as you will see later, the write sequences and the offsets at which they occur, didn't really fit my exploitation plan. So for now, we'll find a 2nd write in the same code path. 

 Immediately after the call to `io_fill_cqe_aux`, there is one to `io_commit_cqring` using our faked `io_uring_ctx`:
 ```c
static inline void io_commit_cqring(struct io_ring_ctx *ctx)
{
	/* order cqe stores with ring update */
	smp_store_release(&ctx->rings->cq.tail, ctx->cached_cq_tail);
}
```

This is basically a `memcpy`, we write the contents of `ctx->cached_cq_tail` (100% user-controlled) to `&ctx->ring->cq.tail` (100% user-controlled). The size of the write in this case is 4 bytes. So we have achieved an arbitrary 4 byte write. From here, it just boils down to what type of exploit you want to write, so I decided to do one I had never done in the spirit of my self-imposed challenge. 

## Exploitation Plan
Now that we have all the possible tools we could need, it was time to start crafting an exploitation plan. In the kCTF environment you are running as an unprivileged user inside of a container, and your goal is to escape the container and read the flag value from the host file system. 

I honestly had no idea where to start in this regard, but luckily there are some good articles out there explaining the situation. [This post from Cyberark](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) was extremely helpful in understanding how containerization of a task is achieved in the kernel. And I also got some very helpful pointers from Andy Nguyen's [blog post](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html) on his kCTF exploit. Huge thanks to Andy for being one of the few to actually detail their steps for escaping the container.

### Finding Init
At this point, my goal is to find the host Init `task_struct` in memory and find the value of a few important members: `real_cred`, `cred`, and `nsproxy`. `real_cred` is used to track the user and group IDs that were originally responsible for creating the process and unlike `cred`, `real_cred` remains constant and does not change due to things like `setuid`. `cred` is used to convey the "effective" credentials of a task, like the effective user ID for instance. Finally, and super importantly because we are trapped in a container, `nsproxy` is a pointer to a struct that contains all of the information about our task's namespaces like network, mount, IPC, etc. All of these members are pointers, so if we are able to find their values via our arbitrary read, we should then be able to overwrite our own credentials and namespace in our `task_struct`. Luckily, the address of the `init` task is a constant offset from the kernel base, so once we broke KASLR with our read of the `error_entry` address, we can then copy those values with our arbitrary read capability. 

